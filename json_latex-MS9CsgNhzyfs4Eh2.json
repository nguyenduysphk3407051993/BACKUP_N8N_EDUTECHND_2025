{"createdAt":"2025-10-26T05:25:43.765Z","updatedAt":"2025-10-26T08:27:02.630Z","id":"MS9CsgNhzyfs4Eh2","name":"JSON_LATEX","active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-1008,144],"id":"978bb60f-ba98-4f79-8ec0-1d8fd3d52811","name":"When clicking ‚ÄòExecute workflow‚Äô"},{"parameters":{"mode":"raw","jsonOutput":"={\n  \"cau_hoi_latex\": [\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_1\",\n      \"title\": \"Ch·ªçn c√¢u ƒë√∫ng/sai v·ªÅ nguy√™n t·ªë h√≥a h·ªçc:\",\n      \"choices\": [\n        {\n          \"content\": \"Nguy√™n t·ªë h√≥a h·ªçc l√† t·∫≠p h·ª£p c√°c nguy√™n t·ª≠ c√≥ c√πng s·ªë proton trong h·∫°t nh√¢n\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Nguy√™n t·ª≠ c·ªßa c√πng m·ªôt nguy√™n t·ªë c√≥ s·ªë proton kh√°c nhau\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"S·ªë hi·ªáu nguy√™n t·ª≠ c·ªßa nguy√™n t·ªë b·∫±ng s·ªë proton trong nguy√™n t·ª≠\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Nguy√™n t·ªë h√≥a h·ªçc l√† h·ª£p ch·∫•t c·∫•u t·∫°o t·ª´ nhi·ªÅu nguy√™n t·ª≠ kh√°c lo·∫°i\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"Nguy√™n t·ªë h√≥a h·ªçc ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a l√† t·∫≠p h·ª£p c√°c nguy√™n t·ª≠ c√≥ c√πng s·ªë proton.\",\n        \"C√°c nguy√™n t·ª≠ c·ªßa c√πng m·ªôt nguy√™n t·ªë lu√¥n c√≥ s·ªë proton gi·ªëng nhau.\",\n        \"S·ªë hi·ªáu nguy√™n t·ª≠ ch√≠nh l√† s·ªë proton trong nguy√™n t·ª≠ c·ªßa nguy√™n t·ªë ƒë√≥.\",\n        \"Nguy√™n t·ªë h√≥a h·ªçc kh√¥ng ph·∫£i l√† h·ª£p ch·∫•t, m√† l√† ch·∫•t c·∫•u t·∫°o t·ª´ m·ªôt lo·∫°i nguy√™n t·ª≠.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"EX_1\",\n      \"title\": \"Ph√°t bi·ªÉu n√†o sau ƒë√¢y bi·ªÉu di·ªÖn ƒë√∫ng \\\"ba ph√¢n t·ª≠ kh√≠ hiƒëro\\\"?\",\n      \"choices\": [\n        { \"content\": \"$3H$\", \"correct\": false },\n        { \"content\": \"$H_3$\", \"correct\": false },\n        { \"content\": \"$H_2$\", \"correct\": false },\n        { \"content\": \"$3H_2$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"$3H$: bi·ªÉu di·ªÖn ba nguy√™n t·ª≠ hiƒëro.\",\n        \"$H_3$: bi·ªÉu di·ªÖn m·ªôt ph√¢n t·ª≠ hiƒëro g·ªìm ba nguy√™n t·ª≠ (kh√¥ng t·ªìn t·∫°i trong ƒëi·ªÅu ki·ªán th∆∞·ªùng).\",\n        \"$H_2$: bi·ªÉu di·ªÖn m·ªôt ph√¢n t·ª≠ kh√≠ hiƒëro.\",\n        \"$3H_2$: bi·ªÉu di·ªÖn ba ph√¢n t·ª≠ kh√≠ hiƒëro. S·ªë $3$ l√† h·ªá s·ªë ch·ªâ s·ªë l∆∞·ª£ng ph√¢n t·ª≠, c√≤n s·ªë $2$ l√† ch·ªâ s·ªë d∆∞·ªõi ch·ªâ s·ªë l∆∞·ª£ng nguy√™n t·ª≠ trong m·ªôt ph√¢n t·ª≠.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_1\",\n      \"title\": \"Nguy√™n t·ª≠ c·ªßa nguy√™n t·ªë X c√≥ s·ªë hi·ªáu nguy√™n t·ª≠ l√† $12$, s·ªë kh·ªëi l√† $24$. H√£y ho√†n th√†nh b·∫£ng sao cho ƒë√∫ng s·ªë proton, electron v√† neutron c·ªßa nguy√™n t·ª≠ X:\\n¬† \\\\begin{tabular}{|c|c|c|c|}\\n¬† ¬† \\\\hline\\n¬† ¬† S·ªë proton & S·ªë electron & S·ªë neutron & T√™n nguy√™n t·ªë \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† ¬† \\\\ & \\\\ & \\\\ & Magie ($Mg$) \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"V√¨ nguy√™n t·ª≠ trung h√≤a ƒëi·ªán n√™n s·ªë proton = s·ªë electron = s·ªë hi·ªáu nguy√™n t·ª≠ = $12$.\",\n        \"S·ªë neutron = s·ªë kh·ªëi - s·ªë proton = $24 - 12 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_1\",\n      \"title\": \"Nguy√™n t·ª≠ c·ªßa nguy√™n t·ªë X c√≥ t·ªïng s·ªë proton v√† neutron trong h·∫°t nh√¢n l√† $23$, trong ƒë√≥ s·ªë proton l√† $11$. H√£y t√≠nh s·ªë neutron trong nguy√™n t·ª≠ X.\",\n      \"choices\": [\n        { \"content\": \"$12$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"S·ªë neutron b·∫±ng t·ªïng s·ªë proton v√† neutron tr·ª´ ƒëi s·ªë proton, t·ª©c l√† $23 - 11 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"EX_2\",\n      \"title\": \"Cho c√¥ng th·ª©c h√≥a h·ªçc $2Al_2O_3$. Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† ƒë√∫ng?\",\n      \"choices\": [\n        { \"content\": \"C√≥ $2$ nguy√™n t·ª≠ nh√¥m trong c√¥ng th·ª©c tr√™n\", \"correct\": false },\n        { \"content\": \"C√≥ $3$ nguy√™n t·ª≠ oxi trong c√¥ng th·ª©c tr√™n\", \"correct\": false },\n        { \"content\": \"C√¥ng th·ª©c tr√™n bi·ªÉu di·ªÖn $2$ ph√¢n t·ª≠ $Al_2O_3$\", \"correct\": false },\n        { \"content\": \"T·ªïng c·ªông c√≥ $4$ nguy√™n t·ª≠ nh√¥m v√† $6$ nguy√™n t·ª≠ oxi\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"H·ªá s·ªë $2$ ph√≠a tr∆∞·ªõc c√¥ng th·ª©c $Al_2O_3$ cho bi·∫øt c√≥ $2$ ph√¢n t·ª≠ $Al_2O_3$.\",\n        \"Trong m·ªói ph√¢n t·ª≠ $Al_2O_3$, c√≥ $2$ nguy√™n t·ª≠ nh√¥m ($Al$) v√† $3$ nguy√™n t·ª≠ oxi ($O$).\",\n        \"Do ƒë√≥, trong $2$ ph√¢n t·ª≠ $Al_2O_3$: S·ªë nguy√™n t·ª≠ nh√¥m l√† $2 \\\\times 2 = 4$ nguy√™n t·ª≠.\",\n        \"S·ªë nguy√™n t·ª≠ oxi l√† $2 \\\\times 3 = 6$ nguy√™n t·ª≠. V·∫≠y, ph√°t bi·ªÉu \\\"T·ªïng c·ªông c√≥ $4$ nguy√™n t·ª≠ nh√¥m v√† $6$ nguy√™n t·ª≠ oxi\\\" l√† ƒë√∫ng.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_3\",\n      \"title\": \"M·ªôt nguy√™n t·ª≠ Z c√≥ s·ªë proton v√† electron b·∫±ng nhau l√† $12$, t·ªïng s·ªë proton v√† neutron l√† $24$. H√£y t√≠nh s·ªë neutron trong nguy√™n t·ª≠ Z.\",\n      \"choices\": [\n        { \"content\": \"$12$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"S·ªë neutron b·∫±ng t·ªïng s·ªë proton v√† neutron tr·ª´ ƒëi s·ªë proton, t·ª©c l√† $24 - 12 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_2\",\n      \"title\": \"Nguy√™n t·ª≠ c·ªßa nguy√™n t·ªë Y c√≥ s·ªë kh·ªëi l√† $35$ v√† s·ªë neutron l√† $18$. H√£y x√°c ƒë·ªãnh s·ªë proton c·ªßa nguy√™n t·ª≠ Y.\",\n      \"choices\": [\n        { \"content\": \"$17$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"S·ªë proton b·∫±ng s·ªë kh·ªëi tr·ª´ s·ªë neutron, t·ª©c l√† $35 - 18 = 17$.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_2\",\n      \"title\": \"Nguy√™n t·ª≠ c√≥ k√Ω hi·ªáu $Na$ v·ªõi s·ªë proton l√† $11$ v√† s·ªë neutron l√† $12$. Ho√†n th√†nh b·∫£ng th√¥ng tin d∆∞·ªõi ƒë√¢y:\\n¬† \\\\begin{tabular}{|c|c|c|c|}\\n¬† ¬† \\\\hline\\n¬† ¬† K√Ω hi·ªáu nguy√™n t·ªë & S·ªë proton & S·ªë electron & S·ªë kh·ªëi \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† ¬† \\\\ & $11$ & \\\\ & $23$ \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"S·ªë electron c·ªßa nguy√™n t·ª≠ trung h√≤a = s·ªë proton = $11$.\",\n        \"S·ªë kh·ªëi = s·ªë proton + s·ªë neutron = $11 + 12 = 23$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_3\",\n      \"title\": \"V·ªÅ s·ªë hi·ªáu nguy√™n t·ª≠ v√† s·ªë kh·ªëi c·ªßa nguy√™n t·ª≠, ch·ªçn ph√°t bi·ªÉu ƒë√∫ng/sai:\",\n      \"choices\": [\n        {\n          \"content\": \"S·ªë hi·ªáu nguy√™n t·ª≠ l√† s·ªë proton trong h·∫°t nh√¢n\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"S·ªë kh·ªëi l√† t·ªïng s·ªë proton v√† electron\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"S·ªë neutron = s·ªë kh·ªëi tr·ª´ s·ªë hi·ªáu nguy√™n t·ª≠\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"S·ªë hi·ªáu nguy√™n t·ª≠ b·∫±ng s·ªë neutron\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"S·ªë hi·ªáu nguy√™n t·ª≠ b·∫±ng s·ªë proton c·ªßa nguy√™n t·ª≠.\",\n        \"S·ªë kh·ªëi b·∫±ng t·ªïng s·ªë proton v√† neutron, kh√¥ng ph·∫£i proton v√† electron.\",\n        \"S·ªë neutron l√† hi·ªáu gi·ªØa s·ªë kh·ªëi v√† s·ªë hi·ªáu nguy√™n t·ª≠.\",\n        \"S·ªë hi·ªáu nguy√™n t·ª≠ kh√¥ng b·∫±ng s·ªë neutron.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_3\",\n      \"title\": \"Nguy√™n t·ª≠ A c√≥ s·ªë electron b·∫±ng s·ªë proton v√† t·ªïng s·ªë proton c√πng neutron l√† $35$. K√Ω hi·ªáu nguy√™n t·ªë l√† $Cl$. H√£y ƒëi·ªÅn c√°c th√¥ng tin c√≤n thi·∫øu v√†o b·∫£ng sau:\\n¬† \\\\begin{tabular}{|c|c|c|c|c|}\\n¬† ¬† \\\\hline\\n¬† ¬† K√Ω hi·ªáu & S·ªë proton & S·ªë electron & S·ªë neutron & S·ªë kh·ªëi \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† ¬† $Cl$ & \\\\ & \\\\ & \\\\ & $35$ \\\\\\\\\\n¬† ¬† \\\\hline\\n¬† \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"S·ªë proton = s·ªë electron = s·ªë hi·ªáu nguy√™n t·ª≠ c·ªßa $Cl = 17$.\",\n        \"S·ªë neutron = s·ªë kh·ªëi - s·ªë proton = $35 - 17 = 18$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_2\",\n      \"title\": \"Ch·ªçn c√¢u ƒë√∫ng/sai li√™n quan ƒë·∫øn k√≠ hi·ªáu h√≥a h·ªçc v√† nguy√™n t·ª≠:\",\n      \"choices\": [\n        {\n          \"content\": \"K√Ω hi·ªáu h√≥a h·ªçc c·ªßa v√†ng l√† $Au$\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"K√Ω hi·ªáu c·ªßa oxy l√† $Ox$\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"Electron mang ƒëi·ªán √¢m\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Proton mang ƒëi·ªán kh√¥ng x√°c ƒë·ªãnh\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"V√†ng c√≥ k√Ω hi·ªáu h√≥a h·ªçc l√† $Au$ d·ª±a tr√™n t√™n ti·∫øng Latin Aurum.\",\n        \"K√Ω hi·ªáu oxy l√† $O$, kh√¥ng ph·∫£i $Ox$.\",\n        \"Electron mang ƒëi·ªán t√≠ch √¢m.\",\n        \"Proton mang ƒëi·ªán t√≠ch d∆∞∆°ng, kh√¥ng ph·∫£i ƒëi·ªán t√≠ch kh√¥ng x√°c ƒë·ªãnh.\"\n      ]\n    }\n  ]\n}","options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-768,144],"id":"e291266d-70cd-49ef-a597-897d609d2d85","name":"JSON_LATEX"},{"parameters":{"assignments":{"assignments":[{"id":"6f29acc6-bf36-4ca3-8aa2-23c1d5e4d340","name":"EX","value":"={{ $json.EX }}","type":"string"},{"id":"8a9f4015-3fdd-4b65-95e5-c84218141501","name":"TF","value":"={{ $json.TF }}","type":"string"},{"id":"86e9fb10-eb33-4f8a-92bf-da24f05c25d4","name":"SA","value":"={{ $json.SA }}","type":"string"},{"id":"20125a7a-4644-4573-ad79-b4603d058bba","name":"BT","value":"={{ $json.BT }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-96,144],"id":"4d92f291-729e-4525-a2a3-ff7ba8bbccc5","name":"CODE_LATEX"},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filename_output","value":"=Create_TF_{{$now.format('hh_mm_ss-dd_MM_yyyy')}}.txt","type":"string"},{"id":"1c218b8e-1ad2-48f4-96cf-5dc4c5b5d72e","name":"content_to_write","value":"={{ $json.latex_output }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[416,-160],"id":"1664e010-40c6-4e93-811b-2b5c9699ee63","name":"Tempt"},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filepath","value":"={{ $json.file_created .replaceAll(`app`,`files`)}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[1008,-160],"id":"081f3186-0cb0-4c64-a91b-6bfe1ea80c9d","name":"input_file1"},{"parameters":{"fileSelector":"={{ $json.filepath }}","options":{}},"type":"n8n-nodes-base.readWriteFile","typeVersion":1,"position":[1168,-160],"id":"9b38e8ad-d078-4ef8-869c-b86cd543c28d","name":"Read/Write Files from Disk","alwaysOutputData":true},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filename_output","value":"={{ $json.filename_output }}","type":"string"},{"id":"1c218b8e-1ad2-48f4-96cf-5dc4c5b5d72e","name":"=content_to_write","value":"={{ $json.content_to_write }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[592,-160],"id":"6df86b79-6df6-47a7-aeb5-c12c3c0a6d56","name":"file_content1"},{"parameters":{"method":"POST","url":"http://python_service:5000/execute-task","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"task_name\": \"write_file\",\n  \"payload\": {\n    \"filepath\": \"./latex_document/{{ $json.filename_output }}\",\n    \"content\": {{ JSON.stringify($json.content_to_write) }}\n  }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[816,-160],"id":"e8b7ae13-ff05-4294-acc1-59114c62b01d","name":"write_file_request1"},{"parameters":{"jsCode":"// ‚ö° ƒê√¢y l√† h√†m \"th·∫ßn k·ª≥\" gi√∫p chuy·ªÉn ƒë·ªïi text th∆∞·ªùng sang LaTeX kh√¥ng ƒë·∫£o c√°c ph∆∞∆°ng √°n ID EX v√† TF\n// N√≥ s·∫Ω t√¨m c√°c c√¥ng th·ª©c (H_2, Fe^{3+}) v√† c√°c con s·ªë (2, 3) ƒë·ªÉ b·ªçc ch√∫ng b·∫±ng $...$\nconst latexify = (text) => {\n  // 1. Wrap c√°c bi·ªÉu th·ª©c to√°n h·ªçc (v√≠ d·ª•: 2 √ó 2 = 4)\n  // \\u00D7 l√† k√Ω t·ª± '√ó', \\u002A l√† '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. X·ª≠ l√Ω ph·∫ßn text c√≤n l·∫°i\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // üî•FIX (PH∆Ø∆†NG √ÅN B+): ƒê√£ c·∫≠p nh·∫≠t regex ƒë·ªÉ bao g·ªìm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // ƒê√¢y l√† text th∆∞·ªùng (n·∫±m ngo√†i d·∫•u $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap c√°c c√¥ng th·ª©c h√≥a h·ªçc (d√πng regex m·ªõi)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap c√°c con s·ªë ƒë·ªôc l·∫≠p\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text th∆∞·ªùng, wrap s·ªë\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // C√¥ng th·ª©c, gi·ªØ nguy√™n\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // ƒê√¢y l√† text to√°n h·ªçc (n·∫±m trong d·∫•u $...$), gi·ªØ nguy√™n\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // D·ªçn d·∫πp n·∫øu c√≥ $$ tr·ªëng\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n\n// === PH·∫¶N X·ª¨ L√ù CH√çNH TRONG N8N ===\n\n// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// L·∫∑p qua t·ª´ng item (v√≠ d·ª•: n·∫øu node tr∆∞·ªõc tr·∫£ v·ªÅ nhi·ªÅu JSON)\nfor (const item of items) {\n  // üî• C·∫¨P NH·∫¨T: X·ª≠ l√Ω JSON b·ªã l·ªìng (flat map)\n  // D·ªØ li·ªáu JSON c·ªßa b·∫°n c√≥ c·∫•u tr√∫c l·ªìng nhau, ta c·∫ßn l√†m ph·∫≥ng n√≥\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // ƒê·∫£m b·∫£o rawQuestionData l√† m·∫£ng tr∆∞·ªõc khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n  \n  // M·∫£ng n√†y s·∫Ω ch·ª©a c√°c chu·ªói LaTeX cho T·ª™NG c√¢u h·ªèi\n  const questionLatexStrings = [];\n\n  // üèóÔ∏è D√πng v√≤ng l·∫∑p for...of ƒë·ªÉ duy·ªát qua t·ª´ng c√¢u h·ªèi\n  for (const question of questions) {\n    \n    // Th√™m header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // üî• C·∫¨P NH·∫¨T: D√πng \\begin{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Th√™m ti√™u ƒë·ªÅ (ƒë√£ ƒë∆∞·ª£c \"latexify\")\n    // Th√™m \\n ƒë·ªÉ xu·ªëng d√≤ng cho ƒë·∫πp\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // üî• --- START C·∫¨P NH·∫¨T LOGIC 4 NH√ÅNH (EX, TF, SA, BT) ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT'); // M·ªõi\n    \n    // 1. Th√™m kh·ªëi l·ª±a ch·ªçn \\choice, \\choiceTF, \\shortans, ho·∫∑c kh√¥ng g√¨ c·∫£\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      // L·∫•y ƒë√°p √°n ng·∫Øn t·ª´ \"choices\"\n      const answer = question.choices[0].content;\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua c√°c l·ª±a ch·ªçn (CH·ªà D√ÄNH CHO EX v√† TF)\n    if (!isShortAnswer && !isTableExercise) { // Th√™m !isTableExercise\n      for (const choice of question.choices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Th√™m kh·ªëi l·ªùi gi·∫£i\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- L·ªùi gi·∫£i cho TF ---\n      const keyParts = [];\n      question.choices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of question.explanation) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- L·ªùi gi·∫£i cho SA ---\n      // Gh√©p c√°c d√≤ng gi·∫£i th√≠ch th√†nh 1 ƒëo·∫°n vƒÉn\n      const explanationText = question.explanation.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- L·ªùi gi·∫£i cho EX v√† BT (d√πng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      for (const line of question.explanation) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // üî• C·∫¨P NH·∫¨T: D√πng \\end{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n    // üî• --- END C·∫¨P NH·∫¨T ---\n  }\n  \n  // N·ªëi t·∫•t c·∫£ c√°c c√¢u h·ªèi c·ªßa item n√†y l·∫°i, c√°ch nhau 2 d√≤ng m·ªõi\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\nreturn [{\n  json: {\n    // N·ªëi k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ item ƒë·∫ßu v√†o\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-512,-528],"id":"1f9d113a-1610-4f1f-9cff-1c8cc646008d","name":"Convert_code_latex_non_dao_pa"},{"parameters":{"jsCode":"// ‚ö° ƒê√¢y l√† h√†m \"th·∫ßn k·ª≥\" gi√∫p chuy·ªÉn ƒë·ªïi text th∆∞·ªùng sang LaTeX\n// N√≥ s·∫Ω t√¨m c√°c c√¥ng th·ª©c (H_2, Fe^{3+}) v√† c√°c con s·ªë (2, 3) ƒë·ªÉ b·ªçc ch√∫ng b·∫±ng $...$\nconst latexify = (text) => {\n  // 1. Wrap c√°c bi·ªÉu th·ª©c to√°n h·ªçc (v√≠ d·ª•: 2 √ó 2 = 4)\n  // \\u00D7 l√† k√Ω t·ª± '√ó', \\u002A l√† '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. X·ª≠ l√Ω ph·∫ßn text c√≤n l·∫°i\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // üî•FIX (PH∆Ø∆†NG √ÅN B+): ƒê√£ c·∫≠p nh·∫≠t regex ƒë·ªÉ bao g·ªìm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // ƒê√¢y l√† text th∆∞·ªùng (n·∫±m ngo√†i d·∫•u $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap c√°c c√¥ng th·ª©c h√≥a h·ªçc (d√πng regex m·ªõi)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap c√°c con s·ªë ƒë·ªôc l·∫≠p\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text th∆∞·ªùng, wrap s·ªë\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // C√¥ng th·ª©c, gi·ªØ nguy√™n\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // ƒê√¢y l√† text to√°n h·ªçc (n·∫±m trong d·∫•u $...$), gi·ªØ nguy√™n\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // D·ªçn d·∫πp n·∫øu c√≥ $$ tr·ªëng\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// üî• --- START C·∫¨P NH·∫¨T: Th√™m h√†m Shuffle ---\n/**\n * X√°o tr·ªôn m·ªôt m·∫£ng (Fisher-Yates Shuffle).\n * @param {Array} array M·∫£ng c·∫ßn x√°o tr·ªôn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// üî• --- END C·∫¨P NH·∫¨T ---\n\n\n// === PH·∫¶N X·ª¨ L√ù CH√çNH TRONG N8N ===\n\n// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// L·∫∑p qua t·ª´ng item (v√≠ d·ª•: n·∫øu node tr∆∞·ªõc tr·∫£ v·ªÅ nhi·ªÅu JSON)\nfor (const item of items) {\n  // üî• C·∫¨P NH·∫¨T: X·ª≠ l√Ω JSON b·ªã l·ªìng (flat map)\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // ƒê·∫£m b·∫£o rawQuestionData l√† m·∫£ng tr∆∞·ªõc khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n  \n  // M·∫£ng n√†y s·∫Ω ch·ª©a c√°c chu·ªói LaTeX cho T·ª™NG c√¢u h·ªèi\n  const questionLatexStrings = [];\n\n  // üèóÔ∏è D√πng v√≤ng l·∫∑p for...of ƒë·ªÉ duy·ªát qua t·ª´ng c√¢u h·ªèi\n  for (const question of questions) {\n    \n    // Th√™m header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // üî• C·∫¨P NH·∫¨T: D√πng \\begin{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Th√™m ti√™u ƒë·ªÅ (ƒë√£ ƒë∆∞·ª£c \"latexify\")\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // --- X√°c ƒë·ªãnh lo·∫°i c√¢u h·ªèi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // üî• --- START C·∫¨P NH·∫¨T: Logic Shuffle ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    // Ch·ªâ shuffle cho EX v√† TF, v√† ph·∫£i ƒë·∫£m b·∫£o 2 m·∫£ng ƒë·ªìng b·ªô\n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      // 1. \"Zip\" 2 m·∫£ng l·∫°i\n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      // 2. Shuffle m·∫£ng \"zipped\"\n      shuffleArray(combined);\n      \n      // 3. \"Unzip\" m·∫£ng ƒë√£ shuffle\n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    // üî• --- END C·∫¨P NH·∫¨T: Logic Shuffle ---\n    \n    // 1. Th√™m kh·ªëi l·ª±a ch·ªçn \\choice, \\choiceTF, \\shortans, ho·∫∑c kh√¥ng g√¨ c·∫£\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content; // D√πng processedChoices\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua c√°c l·ª±a ch·ªçn (CH·ªà D√ÄNH CHO EX v√† TF)\n    if (!isShortAnswer && !isTableExercise) {\n      // üî• C·∫¨P NH·∫¨T: D√πng processedChoices\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Th√™m kh·ªëi l·ªùi gi·∫£i\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- L·ªùi gi·∫£i cho TF ---\n      const keyParts = [];\n      // üî• C·∫¨P NH·∫¨T: D√πng processedChoices ƒë·ªÉ t·∫°o key m·ªõi\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(','); // Key m·ªõi: [T1,T2,F3,F4]\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      // üî• C·∫¨P NH·∫¨T: D√πng processedExplanations\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- L·ªùi gi·∫£i cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- L·ªùi gi·∫£i cho EX v√† BT (d√πng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      // üî• C·∫¨P NH·∫¨T: D√πng processedExplanations\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // üî• C·∫¨P NH·∫¨T: D√πng \\end{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n  }\n  \n  // N·ªëi t·∫•t c·∫£ c√°c c√¢u h·ªèi c·ªßa item n√†y l·∫°i, c√°ch nhau 2 d√≤ng m·ªõi\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\nreturn [{\n  json: {\n    // N·ªëi k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ item ƒë·∫ßu v√†o\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-240,-528],"id":"8b328d4a-603e-453f-b906-35ac86c8af11","name":"Convert_to_latex_dao_PA1"},{"parameters":{"jsCode":"// ‚ö° ƒê√¢y l√† h√†m \"th·∫ßn k·ª≥\" gi√∫p chuy·ªÉn ƒë·ªïi text th∆∞·ªùng sang LaTeX\n// N√≥ s·∫Ω t√¨m c√°c c√¥ng th·ª©c (H_2, Fe^{3+}) v√† c√°c con s·ªë (2, 3) ƒë·ªÉ b·ªçc ch√∫ng b·∫±ng $...$\nconst latexify = (text) => {\n  // 1. Wrap c√°c bi·ªÉu th·ª©c to√°n h·ªçc (v√≠ d·ª•: 2 √ó 2 = 4)\n  // \\u00D7 l√† k√Ω t·ª± '√ó', \\u002A l√† '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. X·ª≠ l√Ω ph·∫ßn text c√≤n l·∫°i\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // üî•FIX (PH∆Ø∆†NG √ÅN B+): ƒê√£ c·∫≠p nh·∫≠t regex ƒë·ªÉ bao g·ªìm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // ƒê√¢y l√† text th∆∞·ªùng (n·∫±m ngo√†i d·∫•u $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap c√°c c√¥ng th·ª©c h√≥a h·ªçc (d√πng regex m·ªõi)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap c√°c con s·ªë ƒë·ªôc l·∫≠p\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text th∆∞·ªùng, wrap s·ªë\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // C√¥ng th·ª©c, gi·ªØ nguy√™n\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // ƒê√¢y l√† text to√°n h·ªçc (n·∫±m trong d·∫•u $...$), gi·ªØ nguy√™n\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // D·ªçn d·∫πp n·∫øu c√≥ $$ tr·ªëng\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// üî• --- START C·∫¨P NH·∫¨T: Th√™m h√†m Shuffle ---\n/**\n * X√°o tr·ªôn m·ªôt m·∫£ng (Fisher-Yates Shuffle).\n * @param {Array} array M·∫£ng c·∫ßn x√°o tr·ªôn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// üî• --- END C·∫¨P NH·∫¨T ---\n\n\n// === PH·∫¶N X·ª¨ L√ù CH√çNH TRONG N8N ===\n\n// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// L·∫∑p qua t·ª´ng item (v√≠ d·ª•: n·∫øu node tr∆∞·ªõc tr·∫£ v·ªÅ nhi·ªÅu JSON)\nfor (const item of items) {\n  // üî• C·∫¨P NH·∫¨T: X·ª≠ l√Ω JSON b·ªã l·ªìng (flat map)\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // ƒê·∫£m b·∫£o rawQuestionData l√† m·∫£ng tr∆∞·ªõc khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // üî• --- START C·∫¨P NH·∫¨T M·ªöI: X√°o tr·ªôn v·ªã tr√≠ c√°c c√¢u h·ªèi ---\n  // D√≤ng n√†y s·∫Ω x√°o tr·ªôn th·ª© t·ª± c·ªßa [EX_1, EX_2, TF_1, SA_1, BT_1, ...]\n  shuffleArray(questions);\n  // üî• --- END C·∫¨P NH·∫¨T M·ªöI ---\n\n  // M·∫£ng n√†y s·∫Ω ch·ª©a c√°c chu·ªói LaTeX cho T·ª™NG c√¢u h·ªèi\n  const questionLatexStrings = [];\n\n  // üèóÔ∏è D√πng v√≤ng l·∫∑p for...of ƒë·ªÉ duy·ªát qua t·ª´ng c√¢u h·ªèi (theo th·ª© t·ª± ƒë√£ x√°o tr·ªôn)\n  for (const question of questions) {\n    \n    // Th√™m header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // üî• C·∫¨P NH·∫¨T: D√πng \\begin{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Th√™m ti√™u ƒë·ªÅ (ƒë√£ ƒë∆∞·ª£c \"latexify\")\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // --- X√°c ƒë·ªãnh lo·∫°i c√¢u h·ªèi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // üî• --- START C·∫¨P NH·∫¨T: Logic Shuffle (b√™n trong c√¢u h·ªèi) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    // Ch·ªâ shuffle cho EX v√† TF, v√† ph·∫£i ƒë·∫£m b·∫£o 2 m·∫£ng ƒë·ªìng b·ªô\n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      // 1. \"Zip\" 2 m·∫£ng l·∫°i\n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      // 2. Shuffle m·∫£ng \"zipped\" (Shuffle b√™n trong)\n      shuffleArray(combined);\n      \n      // 3. \"Unzip\" m·∫£ng ƒë√£ shuffle\n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    // üî• --- END C·∫¨P NH·∫¨T: Logic Shuffle (b√™n trong c√¢u h·ªèi) ---\n    \n    // 1. Th√™m kh·ªëi l·ª±a ch·ªçn \\choice, \\choiceTF, \\shortans, ho·∫∑c kh√¥ng g√¨ c·∫£\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content; // D√πng processedChoices\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua c√°c l·ª±a ch·ªçn (CH·ªà D√ÄNH CHO EX v√† TF)\n    if (!isShortAnswer && !isTableExercise) {\n      // üî• C·∫¨P NH·∫¨T: D√πng processedChoices (ƒë√£ x√°o tr·ªôn)\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Th√™m kh·ªëi l·ªùi gi·∫£i\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- L·ªùi gi·∫£i cho TF ---\n      const keyParts = [];\n      // üî• C·∫¨P NH·∫¨T: D√πng processedChoices (ƒë√£ x√°o tr·ªôn) ƒë·ªÉ t·∫°o key m·ªõi\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(','); // Key m·ªõi: [T1,T2,F3,F4]\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      // üî• C·∫¨P NH·∫¨T: D√πng processedExplanations (ƒë√£ x√°o tr·ªôn)\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- L·ªùi gi·∫£i cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- L·ªùi gi·∫£i cho EX v√† BT (d√πng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      // üî• C·∫¨P NH·∫¨T: D√πng processedExplanations (ƒë√£ x√°o tr·ªôn n·∫øu l√† EX)\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // üî• C·∫¨P NH·∫¨T: D√πng \\end{bt} n·∫øu l√† BT, ng∆∞·ª£c l·∫°i d√πng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n  }\n  \n  // N·ªëi t·∫•t c·∫£ c√°c c√¢u h·ªèi c·ªßa item n√†y l·∫°i, c√°ch nhau 2 d√≤ng m·ªõi\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\nreturn [{\n  json: {\n    // N·ªëi k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ item ƒë·∫ßu v√†o\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[368,-528],"id":"3951e7e7-0274-4999-89ba-595fe662559a","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi"},{"parameters":{"jsCode":"// ‚ö° ƒê√¢y l√† h√†m \"th·∫ßn k·ª≥\" gi√∫p chuy·ªÉn ƒë·ªïi text th∆∞·ªùng sang LaTeX\n// N√≥ s·∫Ω t√¨m c√°c c√¥ng th·ª©c (H_2, Fe^{3+}) v√† c√°c con s·ªë (2, 3) ƒë·ªÉ b·ªçc ch√∫ng b·∫±ng $...$\nconst latexify = (text) => {\n  // 1. Wrap c√°c bi·ªÉu th·ª©c to√°n h·ªçc (v√≠ d·ª•: 2 √ó 2 = 4)\n  // \\u00D7 l√† k√Ω t·ª± '√ó', \\u002A l√† '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. X·ª≠ l√Ω ph·∫ßn text c√≤n l·∫°i\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // üî•FIX (PH∆Ø∆†NG √ÅN B+): ƒê√£ c·∫≠p nh·∫≠t regex ƒë·ªÉ bao g·ªìm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // ƒê√¢y l√† text th∆∞·ªùng (n·∫±m ngo√†i d·∫•u $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap c√°c c√¥ng th·ª©c h√≥a h·ªçc (d√πng regex m·ªõi)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap c√°c con s·ªë ƒë·ªôc l·∫≠p\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text th∆∞·ªùng, wrap s·ªë\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // C√¥ng th·ª©c, gi·ªØ nguy√™n\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // ƒê√¢y l√† text to√°n h·ªçc (n·∫±m trong d·∫•u $...$), gi·ªØ nguy√™n\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // D·ªçn d·∫πp n·∫øu c√≥ $$ tr·ªëng\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// üî• --- START: Th√™m h√†m Shuffle ---\n/**\n * X√°o tr·ªôn m·ªôt m·∫£ng (Fisher-Yates Shuffle).\n * @param {Array} array M·∫£ng c·∫ßn x√°o tr·ªôn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// üî• --- END: Th√™m h√†m Shuffle ---\n\n// üî• --- START: H√†m x·ª≠ l√Ω m·∫£ng c√¢u h·ªèi ---\n/**\n * X·ª≠ l√Ω m·ªôt m·∫£ng c√°c c√¢u h·ªèi v√† tr·∫£ v·ªÅ m·ªôt m·∫£ng c√°c chu·ªói LaTeX.\n * @param {Array} questionArray - M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng c√¢u h·ªèi (v√≠ d·ª•: exQuestions).\n * @returns {Array<string>} - M·∫£ng c√°c chu·ªói LaTeX ƒë√£ x·ª≠ l√Ω.\n */\nconst processQuestionsToLatex = (questionArray) => {\n  // Bi·∫øn n√†y ch·ª©a T·∫§T C·∫¢ c√°c chu·ªói LaTeX c·ªßa c√°c c√¢u h·ªèi trong nh√≥m n√†y\n  const allQuestionStrings = []; \n  \n  // üèóÔ∏è D√πng v√≤ng l·∫∑p for...of ƒë·ªÉ duy·ªát qua t·ª´ng c√¢u h·ªèi (theo th·ª© t·ª± ƒë√£ x√°o tr·ªôn)\n  for (const question of questionArray) {\n    // üî• FIX L√Ä ·ªû ƒê√ÇY:\n    // Bi·∫øn n√†y CH·ªà ch·ª©a c√°c d√≤ng cho M·ªòT c√¢u h·ªèi\n    const singleQuestionLines = []; \n\n    // Th√™m header\n    singleQuestionLines.push(`%%%============${question.id}=============%%%`);\n    if (question.id.includes('BT')) {\n      singleQuestionLines.push(`\\\\begin{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\begin{ex}`);\n    }\n    \n    // Th√™m ti√™u ƒë·ªÅ\n    singleQuestionLines.push(`  ${latexify(question.title)}`);\n    \n    // --- X√°c ƒë·ªãnh lo·∫°i c√¢u h·ªèi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // --- Logic Shuffle (b√™n trong c√¢u h·ªèi EX/TF) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      shuffleArray(combined); // Shuffle b√™n trong\n      \n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    \n    // 1. Th√™m kh·ªëi l·ª±a ch·ªçn\n    if (isTrueFalse) {\n      singleQuestionLines.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content;\n      singleQuestionLines.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT kh√¥ng c√≥ kh·ªëi l·ª±a ch·ªçn\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      singleQuestionLines.push(`  \\\\choice`); // D√πng singleQuestionLines\n    }\n    \n    // 2. Loop qua c√°c l·ª±a ch·ªçn (CH·ªà D√ÄNH CHO EX v√† TF)\n    if (!isShortAnswer && !isTableExercise) {\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        singleQuestionLines.push(`  {${choicePrefix}${choiceContent}}`); // D√πng singleQuestionLines\n      }\n    }\n    \n    // 3. Th√™m kh·ªëi l·ªùi gi·∫£i\n    singleQuestionLines.push(`  \\\\loigiai{`); // D√πng singleQuestionLines\n\n    if (isTrueFalse) {\n      // --- L·ªùi gi·∫£i cho TF ---\n      const keyParts = [];\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      singleQuestionLines.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- L·ªùi gi·∫£i cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      singleQuestionLines.push(`    ${explanationText}`);\n\n    } else {\n      // --- L·ªùi gi·∫£i cho EX v√† BT (d√πng itemize) ---\n      singleQuestionLines.push(`    \\\\begin{itemize}`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemize}`);\n    }\n    \n    singleQuestionLines.push(`  }`); // D√πng singleQuestionLines\n    \n    // ƒê√≥ng kh·ªëi \\begin\n    if (isTableExercise) {\n      singleQuestionLines.push(`\\\\end{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\end{ex}`);\n    }\n    \n    // N·ªëi c√°c d√≤ng c·ªßa c√¢u h·ªèi n√†y th√†nh 1 string v√† push v√†o m·∫£ng T·ªîNG\n    allQuestionStrings.push(singleQuestionLines.join('\\n'));\n  }\n  \n  return allQuestionStrings;\n};\n// üî• --- END: H√†m x·ª≠ l√Ω ---\n\n\n// === PH·∫¶N X·ª¨ L√ù CH√çNH TRONG N8N ===\n\n// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\nlet finalOutput = [];\n\n// L·∫∑p qua t·ª´ng item (v√≠ d·ª•: n·∫øu node tr∆∞·ªõc tr·∫£ v·ªÅ nhi·ªÅu JSON)\nfor (const item of items) {\n  // 1. L·∫•y v√† l√†m ph·∫≥ng data\n  const rawQuestionData = item.json.cau_hoi_latex;\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // 2. T·∫°o 4 m·∫£ng ƒë·ªÉ ph√¢n lo·∫°i\n  const exQuestions = [];\n  const tfQuestions = [];\n  const saQuestions = [];\n  const btQuestions = [];\n\n  // 3. Ph√¢n lo·∫°i c√¢u h·ªèi\n  for (const question of questions) {\n    if (question.id.includes('BT')) {\n      btQuestions.push(question);\n    } else if (question.id.includes('TF')) {\n      tfQuestions.push(question);\n    } else if (question.id.includes('SA')) {\n      saQuestions.push(question);\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      exQuestions.push(question);\n    }\n  }\n\n  // 4. X√°o tr·ªôn c√°c c√¢u h·ªèi *trong* t·ª´ng nh√≥m\n  shuffleArray(exQuestions);\n  shuffleArray(tfQuestions);\n  shuffleArray(saQuestions);\n  shuffleArray(btQuestions);\n\n  // 5. X·ª≠ l√Ω t·ª´ng nh√≥m ƒë√£ x√°o tr·ªôn ƒë·ªÉ t·∫°o m·∫£ng string LaTeX\n  const exOutput = processQuestionsToLatex(exQuestions);\n  const tfOutput = processQuestionsToLatex(tfQuestions);\n  const saOutput = processQuestionsToLatex(saQuestions);\n  const btOutput = processQuestionsToLatex(btQuestions);\n\n  // 6. Push k·∫øt qu·∫£ c·ªßa item n√†y v√†o\n  finalOutput.push({\n    json: {\n      EX: exOutput,\n      TF: tfOutput,\n      SA: saOutput,\n      BT: btOutput\n    }\n  });\n}\n\n// üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\n// Tr·∫£ v·ªÅ m·ªôt m·∫£ng c√°c object, m·ªói object t∆∞∆°ng ·ª©ng v·ªõi m·ªôt item ƒë·∫ßu v√†o\n// v√† ch·ª©a 4 m·∫£ng ƒë√£ ƒë∆∞·ª£c ph√¢n lo·∫°i\nreturn finalOutput;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[48,-528],"id":"fcc4b2fd-35ae-46cc-99c5-5b28b13759cf","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID"},{"parameters":{"jsCode":"// ‚ö° ƒê√¢y l√† h√†m \"th·∫ßn k·ª≥\" gi√∫p chuy·ªÉn ƒë·ªïi text th∆∞·ªùng sang LaTeX\n// N√≥ s·∫Ω t√¨m c√°c c√¥ng th·ª©c (H_2, Fe^{3+}) v√† c√°c con s·ªë (2, 3) ƒë·ªÉ b·ªçc ch√∫ng b·∫±ng $...$\nconst latexify = (text) => {\n  // 1. Wrap c√°c bi·ªÉu th·ª©c to√°n h·ªçc (v√≠ d·ª•: 2 √ó 2 = 4)\n  // \\u00D7 l√† k√Ω t·ª± '√ó', \\u002A l√† '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. X·ª≠ l√Ω ph·∫ßn text c√≤n l·∫°i\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // üî•FIX (PH∆Ø∆†NG √ÅN B+): ƒê√£ c·∫≠p nh·∫≠t regex ƒë·ªÉ bao g·ªìm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // ƒê√¢y l√† text th∆∞·ªùng (n·∫±m ngo√†i d·∫•u $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap c√°c c√¥ng th·ª©c h√≥a h·ªçc (d√πng regex m·ªõi)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap c√°c con s·ªë ƒë·ªôc l·∫≠p\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text th∆∞·ªùng, wrap s·ªë\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // C√¥ng th·ª©c, gi·ªØ nguy√™n\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // ƒê√¢y l√† text to√°n h·ªçc (n·∫±m trong d·∫•u $...$), gi·ªØ nguy√™n\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // D·ªçn d·∫πp n·∫øu c√≥ $$ tr·ªëng\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// üî• --- START: Th√™m h√†m Shuffle (D√πng ƒë·ªÉ x√°o tr·ªôn l·ª±a ch·ªçn b√™n trong) ---\n/**\n * X√°o tr·ªôn m·ªôt m·∫£ng (Fisher-Yates Shuffle).\n * @param {Array} array M·∫£ng c·∫ßn x√°o tr·ªôn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// üî• --- END: Th√™m h√†m Shuffle ---\n\n// üî• --- START C·∫¨P NH·∫¨T M·ªöI: Th√™m h√†m l·∫•y s·ªë ID ---\n/**\n * L·∫•y ph·∫ßn s·ªë t·ª´ ID (v√≠ d·ª•: \"EX_10\" -> 10) ƒë·ªÉ s·∫Øp x·∫øp\n * @param {string} id\n * @returns {number}\n */\nconst getIdNumber = (id) => {\n  if (typeof id !== 'string') return 0;\n  const parts = id.split('_');\n  // L·∫•y ph·∫ßn t·ª≠ cu·ªëi c√πng (ph√≤ng tr∆∞·ªùng h·ª£p ID nh∆∞ \"SOME_TF_1\")\n  return parseInt(parts[parts.length - 1] || 0, 10);\n};\n// üî• --- END C·∫¨P NH·∫¨T M·ªöI ---\n\n\n// üî• --- START: H√†m x·ª≠ l√Ω m·∫£ng c√¢u h·ªèi ---\n/**\n * X·ª≠ l√Ω m·ªôt m·∫£ng c√°c c√¢u h·ªèi v√† tr·∫£ v·ªÅ m·ªôt m·∫£ng c√°c chu·ªói LaTeX.\n * @param {Array} questionArray - M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng c√¢u h·ªèi (v√≠ d·ª•: exQuestions).\n * @returns {Array<string>} - M·∫£ng c√°c chu·ªói LaTeX ƒë√£ x·ª≠ l√Ω.\n */\nconst processQuestionsToLatex = (questionArray) => {\n  // Bi·∫øn n√†y ch·ª©a T·∫§T C·∫¢ c√°c chu·ªói LaTeX c·ªßa c√°c c√¢u h·ªèi trong nh√≥m n√†y\n  const allQuestionStrings = []; \n  \n  // üèóÔ∏è D√πng v√≤ng l·∫∑p for...of ƒë·ªÉ duy·ªát qua t·ª´ng c√¢u h·ªèi (theo th·ª© t·ª± ƒë√£ S·∫ÆP X·∫æP)\n  for (const question of questionArray) {\n    // Bi·∫øn n√†y CH·ªà ch·ª©a c√°c d√≤ng cho M·ªòT c√¢u h·ªèi\n    const singleQuestionLines = []; \n\n    // Th√™m header\n    singleQuestionLines.push(`%%%============${question.id}=============%%%`);\n    if (question.id.includes('BT')) {\n      singleQuestionLines.push(`\\\\begin{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\begin{ex}`);\n    }\n    \n    // Th√™m ti√™u ƒë·ªÅ\n    singleQuestionLines.push(`  ${latexify(question.title)}`);\n    \n    // --- X√°c ƒë·ªãnh lo·∫°i c√¢u h·ªèi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // --- Logic Shuffle (b√™n trong c√¢u h·ªèi EX/TF) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      shuffleArray(combined); // Shuffle b√™n trong\n      \n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    \n    // 1. Th√™m kh·ªëi l·ª±a ch·ªçn\n    if (isTrueFalse) {\n      singleQuestionLines.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content;\n      singleQuestionLines.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT kh√¥ng c√≥ kh·ªëi l·ª±a ch·ªçn\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      singleQuestionLines.push(`  \\\\choice`); \n    }\n    \n    // 2. Loop qua c√°c l·ª±a ch·ªçn (CH·ªà D√ÄNH CHO EX v√† TF)\n    if (!isShortAnswer && !isTableExercise) {\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        singleQuestionLines.push(`  {${choicePrefix}${choiceContent}}`); \n      }\n    }\n    \n    // 3. Th√™m kh·ªëi l·ªùi gi·∫£i\n    singleQuestionLines.push(`  \\\\loigiai{`); \n\n    if (isTrueFalse) {\n      // --- L·ªùi gi·∫£i cho TF ---\n      const keyParts = [];\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      singleQuestionLines.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- L·ªùi gi·∫£i cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      singleQuestionLines.push(`    ${explanationText}`);\n\n    } else {\n      // --- L·ªùi gi·∫£i cho EX v√† BT (d√πng itemize) ---\n      singleQuestionLines.push(`    \\\\begin{itemize}`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemize}`);\n    }\n    \n    singleQuestionLines.push(`  }`); \n    \n    // ƒê√≥ng kh·ªëi \\begin\n    if (isTableExercise) {\n      singleQuestionLines.push(`\\\\end{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\end{ex}`);\n    }\n    \n    // N·ªëi c√°c d√≤ng c·ªßa c√¢u h·ªèi n√†y th√†nh 1 string v√† push v√†o m·∫£ng T·ªîNG\n    allQuestionStrings.push(singleQuestionLines.join('\\n'));\n  }\n  \n  return allQuestionStrings;\n};\n// üî• --- END: H√†m x·ª≠ l√Ω ---\n\n\n// === PH·∫¶N X·ª¨ L√ù CH√çNH TRONG N8N ===\n\n// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\nlet finalOutput = [];\n\n// L·∫∑p qua t·ª´ng item (v√≠ d·ª•: n·∫øu node tr∆∞·ªõc tr·∫£ v·ªÅ nhi·ªÅu JSON)\nfor (const item of items) {\n  // 1. L·∫•y v√† l√†m ph·∫≥ng data\n  const rawQuestionData = item.json.cau_hoi_latex;\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // 2. T·∫°o 4 m·∫£ng ƒë·ªÉ ph√¢n lo·∫°i\n  const exQuestions = [];\n  const tfQuestions = [];\n  const saQuestions = [];\n  const btQuestions = [];\n\n  // 3. Ph√¢n lo·∫°i c√¢u h·ªèi\n  for (const question of questions) {\n    if (question.id.includes('BT')) {\n      btQuestions.push(question);\n    } else if (question.id.includes('TF')) {\n      tfQuestions.push(question);\n    } else if (question.id.includes('SA')) {\n      saQuestions.push(question);\n    } else { // M·∫∑c ƒë·ªãnh l√† EX\n      exQuestions.push(question);\n    }\n  }\n\n  // 4. üî• C·∫¨P NH·∫¨T M·ªöI: S·∫Øp x·∫øp c√°c c√¢u h·ªèi *trong* t·ª´ng nh√≥m theo ID\n  const sortById = (a, b) => getIdNumber(a.id) - getIdNumber(b.id);\n  exQuestions.sort(sortById);\n  tfQuestions.sort(sortById);\n  saQuestions.sort(sortById);\n  btQuestions.sort(sortById);\n\n  // 5. X·ª≠ l√Ω t·ª´ng nh√≥m ƒë√£ S·∫ÆP X·∫æP ƒë·ªÉ t·∫°o m·∫£ng string LaTeX\n  const exOutput = processQuestionsToLatex(exQuestions);\n  const tfOutput = processQuestionsToLatex(tfQuestions);\n  const saOutput = processQuestionsToLatex(saQuestions);\n  const btOutput = processQuestionsToLatex(btQuestions);\n\n  // 6. Push k·∫øt qu·∫£ c·ªßa item n√†y v√†o\n  finalOutput.push({\n    json: {\n      EX: exOutput,\n      TF: tfOutput,\n      SA: saOutput,\n      BT: btOutput\n    }\n  });\n}\n\n// üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\n// Tr·∫£ v·ªÅ m·ªôt m·∫£ng c√°c object, m·ªói object t∆∞∆°ng ·ª©ng v·ªõi m·ªôt item ƒë·∫ßu v√†o\n// v√† ch·ª©a 4 m·∫£ng ƒë√£ ƒë∆∞·ª£c ph√¢n lo·∫°i\nreturn finalOutput;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-512,144],"id":"9b8b0869-594f-486a-b44a-b325395cec02","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX"},{"parameters":{"jsCode":"// L·∫•y d·ªØ li·ªáu t·ª´ T·∫§T C·∫¢ item, b·∫•t k·ªÉ ch·∫ø ƒë·ªô Execute Once\nconst items = $input.all();\n\n// üí° D·ªØ li·ªáu c·ªßa b·∫°n l√† m·ªôt m·∫£ng [ { ... } ], ch√∫ng ta c·∫ßn l·∫•y object ƒë·∫ßu ti√™n\nconst inputData = items[0].json;\n\n// 1. Kh·ªüi t·∫°o object k·∫øt qu·∫£\nconst outputObject = {\n  \"EX\": \"\",\n  \"TF\": \"\",\n  \"SA\": \"\",\n  \"BT\": \"\"\n};\n\n// 2. ƒê·ªãnh nghƒ©a c√°c key ch√∫ng ta mu·ªën x·ª≠ l√Ω\nconst keysToProcess = ['EX', 'TF', 'SA', 'BT'];\n\n// üèóÔ∏è D√πng v√≤ng l·∫∑p 'for...of' (m·ªôt d·∫°ng 'for' hi·ªán ƒë·∫°i) ƒë·ªÉ duy·ªát qua c√°c key\nfor (const key of keysToProcess) {\n  \n  // L·∫•y m·∫£ng t∆∞∆°ng ·ª©ng (v√≠ d·ª•: inputData['EX'])\n  const stringArray = inputData[key];\n  \n  // T·∫°o m·ªôt chu·ªói r·ªóng ƒë·ªÉ \"c·ªông d·ªìn\"\n  let concatenatedString = \"\";\n\n  // üèóÔ∏è D√πng v√≤ng l·∫∑p 'for' c·ªï ƒëi·ªÉn (nh∆∞ b·∫°n y√™u c·∫ßu) ƒë·ªÉ duy·ªát qua t·ª´ng ph·∫ßn t·ª≠\n  for (let i = 0; i < stringArray.length; i++) {\n    \n    // N·ªëi (c·ªông) chu·ªói hi·ªán t·∫°i v√†o chu·ªói t·ªïng\n    concatenatedString += stringArray[i];\n    \n    // Th√™m 2 d·∫•u xu·ªëng d√≤ng ƒë·ªÉ ngƒÉn c√°ch c√°c c√¢u h·ªèi cho d·ªÖ ƒë·ªçc\n    // (B·ªè qua n·∫øu l√† ph·∫ßn t·ª≠ cu·ªëi c√πng)\n    if (i < stringArray.length - 1) {\n      concatenatedString += \"\\n\\n\";\n    }\n  }\n  \n  // 3. G√°n chu·ªói ƒë√£ n·ªëi v√†o object k·∫øt qu·∫£\n  outputObject[key] = concatenatedString;\n}\n\n// 4. üöÄ Tr·∫£ v·ªÅ k·∫øt qu·∫£\n// Ch√∫ng ta tr·∫£ v·ªÅ m·ªôt item duy nh·∫•t ch·ª©a object b·∫°n mong mu·ªën\nreturn [{\n  json: outputObject\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-288,144],"id":"58389f5e-3cd2-4b5d-90f7-ef7af74d29a8","name":"JOIN"}],"connections":{"When clicking ‚ÄòExecute workflow‚Äô":{"main":[[{"node":"JSON_LATEX","type":"main","index":0}]]},"JSON_LATEX":{"main":[[{"node":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX","type":"main","index":0}]]},"CODE_LATEX":{"main":[[]]},"Tempt":{"main":[[{"node":"file_content1","type":"main","index":0}]]},"input_file1":{"main":[[{"node":"Read/Write Files from Disk","type":"main","index":0}]]},"file_content1":{"main":[[{"node":"write_file_request1","type":"main","index":0}]]},"write_file_request1":{"main":[[{"node":"input_file1","type":"main","index":0}]]},"Convert_code_latex_non_dao_pa":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX":{"main":[[{"node":"JOIN","type":"main","index":0}]]},"JOIN":{"main":[[{"node":"CODE_LATEX","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":null,"pinData":{},"versionId":"70ac822a-5bae-4880-bb13-5d71365704c2","triggerCount":0,"shared":[{"createdAt":"2025-10-26T05:25:43.765Z","updatedAt":"2025-10-26T05:25:43.765Z","role":"workflow:owner","workflowId":"MS9CsgNhzyfs4Eh2","projectId":"EIQckweL3OLW7kzz"}],"tags":[]}