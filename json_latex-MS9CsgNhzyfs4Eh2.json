{"createdAt":"2025-10-26T05:25:43.765Z","updatedAt":"2025-10-26T08:27:02.630Z","id":"MS9CsgNhzyfs4Eh2","name":"JSON_LATEX","active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-1008,144],"id":"978bb60f-ba98-4f79-8ec0-1d8fd3d52811","name":"When clicking ‘Execute workflow’"},{"parameters":{"mode":"raw","jsonOutput":"={\n  \"cau_hoi_latex\": [\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_1\",\n      \"title\": \"Chọn câu đúng/sai về nguyên tố hóa học:\",\n      \"choices\": [\n        {\n          \"content\": \"Nguyên tố hóa học là tập hợp các nguyên tử có cùng số proton trong hạt nhân\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Nguyên tử của cùng một nguyên tố có số proton khác nhau\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"Số hiệu nguyên tử của nguyên tố bằng số proton trong nguyên tử\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Nguyên tố hóa học là hợp chất cấu tạo từ nhiều nguyên tử khác loại\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"Nguyên tố hóa học được định nghĩa là tập hợp các nguyên tử có cùng số proton.\",\n        \"Các nguyên tử của cùng một nguyên tố luôn có số proton giống nhau.\",\n        \"Số hiệu nguyên tử chính là số proton trong nguyên tử của nguyên tố đó.\",\n        \"Nguyên tố hóa học không phải là hợp chất, mà là chất cấu tạo từ một loại nguyên tử.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"EX_1\",\n      \"title\": \"Phát biểu nào sau đây biểu diễn đúng \\\"ba phân tử khí hiđro\\\"?\",\n      \"choices\": [\n        { \"content\": \"$3H$\", \"correct\": false },\n        { \"content\": \"$H_3$\", \"correct\": false },\n        { \"content\": \"$H_2$\", \"correct\": false },\n        { \"content\": \"$3H_2$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"$3H$: biểu diễn ba nguyên tử hiđro.\",\n        \"$H_3$: biểu diễn một phân tử hiđro gồm ba nguyên tử (không tồn tại trong điều kiện thường).\",\n        \"$H_2$: biểu diễn một phân tử khí hiđro.\",\n        \"$3H_2$: biểu diễn ba phân tử khí hiđro. Số $3$ là hệ số chỉ số lượng phân tử, còn số $2$ là chỉ số dưới chỉ số lượng nguyên tử trong một phân tử.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_1\",\n      \"title\": \"Nguyên tử của nguyên tố X có số hiệu nguyên tử là $12$, số khối là $24$. Hãy hoàn thành bảng sao cho đúng số proton, electron và neutron của nguyên tử X:\\n  \\\\begin{tabular}{|c|c|c|c|}\\n    \\\\hline\\n    Số proton & Số electron & Số neutron & Tên nguyên tố \\\\\\\\\\n    \\\\hline\\n    \\\\ & \\\\ & \\\\ & Magie ($Mg$) \\\\\\\\\\n    \\\\hline\\n  \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"Vì nguyên tử trung hòa điện nên số proton = số electron = số hiệu nguyên tử = $12$.\",\n        \"Số neutron = số khối - số proton = $24 - 12 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_1\",\n      \"title\": \"Nguyên tử của nguyên tố X có tổng số proton và neutron trong hạt nhân là $23$, trong đó số proton là $11$. Hãy tính số neutron trong nguyên tử X.\",\n      \"choices\": [\n        { \"content\": \"$12$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"Số neutron bằng tổng số proton và neutron trừ đi số proton, tức là $23 - 11 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"EX_2\",\n      \"title\": \"Cho công thức hóa học $2Al_2O_3$. Phát biểu nào sau đây là đúng?\",\n      \"choices\": [\n        { \"content\": \"Có $2$ nguyên tử nhôm trong công thức trên\", \"correct\": false },\n        { \"content\": \"Có $3$ nguyên tử oxi trong công thức trên\", \"correct\": false },\n        { \"content\": \"Công thức trên biểu diễn $2$ phân tử $Al_2O_3$\", \"correct\": false },\n        { \"content\": \"Tổng cộng có $4$ nguyên tử nhôm và $6$ nguyên tử oxi\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"Hệ số $2$ phía trước công thức $Al_2O_3$ cho biết có $2$ phân tử $Al_2O_3$.\",\n        \"Trong mỗi phân tử $Al_2O_3$, có $2$ nguyên tử nhôm ($Al$) và $3$ nguyên tử oxi ($O$).\",\n        \"Do đó, trong $2$ phân tử $Al_2O_3$: Số nguyên tử nhôm là $2 \\\\times 2 = 4$ nguyên tử.\",\n        \"Số nguyên tử oxi là $2 \\\\times 3 = 6$ nguyên tử. Vậy, phát biểu \\\"Tổng cộng có $4$ nguyên tử nhôm và $6$ nguyên tử oxi\\\" là đúng.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_3\",\n      \"title\": \"Một nguyên tử Z có số proton và electron bằng nhau là $12$, tổng số proton và neutron là $24$. Hãy tính số neutron trong nguyên tử Z.\",\n      \"choices\": [\n        { \"content\": \"$12$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"Số neutron bằng tổng số proton và neutron trừ đi số proton, tức là $24 - 12 = 12$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"SA_2\",\n      \"title\": \"Nguyên tử của nguyên tố Y có số khối là $35$ và số neutron là $18$. Hãy xác định số proton của nguyên tử Y.\",\n      \"choices\": [\n        { \"content\": \"$17$\", \"correct\": true }\n      ],\n      \"explanation\": [\n        \"Số proton bằng số khối trừ số neutron, tức là $35 - 18 = 17$.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_2\",\n      \"title\": \"Nguyên tử có ký hiệu $Na$ với số proton là $11$ và số neutron là $12$. Hoàn thành bảng thông tin dưới đây:\\n  \\\\begin{tabular}{|c|c|c|c|}\\n    \\\\hline\\n    Ký hiệu nguyên tố & Số proton & Số electron & Số khối \\\\\\\\\\n    \\\\hline\\n    \\\\ & $11$ & \\\\ & $23$ \\\\\\\\\\n    \\\\hline\\n  \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"Số electron của nguyên tử trung hòa = số proton = $11$.\",\n        \"Số khối = số proton + số neutron = $11 + 12 = 23$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_3\",\n      \"title\": \"Về số hiệu nguyên tử và số khối của nguyên tử, chọn phát biểu đúng/sai:\",\n      \"choices\": [\n        {\n          \"content\": \"Số hiệu nguyên tử là số proton trong hạt nhân\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Số khối là tổng số proton và electron\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"Số neutron = số khối trừ số hiệu nguyên tử\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Số hiệu nguyên tử bằng số neutron\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"Số hiệu nguyên tử bằng số proton của nguyên tử.\",\n        \"Số khối bằng tổng số proton và neutron, không phải proton và electron.\",\n        \"Số neutron là hiệu giữa số khối và số hiệu nguyên tử.\",\n        \"Số hiệu nguyên tử không bằng số neutron.\"\n      ]\n    },\n    {\n      \"type\": \"bt\",\n      \"id\": \"BT_3\",\n      \"title\": \"Nguyên tử A có số electron bằng số proton và tổng số proton cùng neutron là $35$. Ký hiệu nguyên tố là $Cl$. Hãy điền các thông tin còn thiếu vào bảng sau:\\n  \\\\begin{tabular}{|c|c|c|c|c|}\\n    \\\\hline\\n    Ký hiệu & Số proton & Số electron & Số neutron & Số khối \\\\\\\\\\n    \\\\hline\\n    $Cl$ & \\\\ & \\\\ & \\\\ & $35$ \\\\\\\\\\n    \\\\hline\\n  \\\\end{tabular}\",\n      \"choices\": [],\n      \"explanation\": [\n        \"Số proton = số electron = số hiệu nguyên tử của $Cl = 17$.\",\n        \"Số neutron = số khối - số proton = $35 - 17 = 18$.\"\n      ]\n    },\n    {\n      \"type\": \"ex\",\n      \"id\": \"TF_2\",\n      \"title\": \"Chọn câu đúng/sai liên quan đến kí hiệu hóa học và nguyên tử:\",\n      \"choices\": [\n        {\n          \"content\": \"Ký hiệu hóa học của vàng là $Au$\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Ký hiệu của oxy là $Ox$\",\n          \"correct\": false\n        },\n        {\n          \"content\": \"Electron mang điện âm\",\n          \"correct\": true\n        },\n        {\n          \"content\": \"Proton mang điện không xác định\",\n          \"correct\": false\n        }\n      ],\n      \"explanation\": [\n        \"Vàng có ký hiệu hóa học là $Au$ dựa trên tên tiếng Latin Aurum.\",\n        \"Ký hiệu oxy là $O$, không phải $Ox$.\",\n        \"Electron mang điện tích âm.\",\n        \"Proton mang điện tích dương, không phải điện tích không xác định.\"\n      ]\n    }\n  ]\n}","options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-768,144],"id":"e291266d-70cd-49ef-a597-897d609d2d85","name":"JSON_LATEX"},{"parameters":{"assignments":{"assignments":[{"id":"6f29acc6-bf36-4ca3-8aa2-23c1d5e4d340","name":"EX","value":"={{ $json.EX }}","type":"string"},{"id":"8a9f4015-3fdd-4b65-95e5-c84218141501","name":"TF","value":"={{ $json.TF }}","type":"string"},{"id":"86e9fb10-eb33-4f8a-92bf-da24f05c25d4","name":"SA","value":"={{ $json.SA }}","type":"string"},{"id":"20125a7a-4644-4573-ad79-b4603d058bba","name":"BT","value":"={{ $json.BT }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-96,144],"id":"4d92f291-729e-4525-a2a3-ff7ba8bbccc5","name":"CODE_LATEX"},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filename_output","value":"=Create_TF_{{$now.format('hh_mm_ss-dd_MM_yyyy')}}.txt","type":"string"},{"id":"1c218b8e-1ad2-48f4-96cf-5dc4c5b5d72e","name":"content_to_write","value":"={{ $json.latex_output }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[416,-160],"id":"1664e010-40c6-4e93-811b-2b5c9699ee63","name":"Tempt"},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filepath","value":"={{ $json.file_created .replaceAll(`app`,`files`)}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[1008,-160],"id":"081f3186-0cb0-4c64-a91b-6bfe1ea80c9d","name":"input_file1"},{"parameters":{"fileSelector":"={{ $json.filepath }}","options":{}},"type":"n8n-nodes-base.readWriteFile","typeVersion":1,"position":[1168,-160],"id":"9b38e8ad-d078-4ef8-869c-b86cd543c28d","name":"Read/Write Files from Disk","alwaysOutputData":true},{"parameters":{"assignments":{"assignments":[{"id":"7eac0a9f-8e37-41e3-944f-095f19e44b74","name":"filename_output","value":"={{ $json.filename_output }}","type":"string"},{"id":"1c218b8e-1ad2-48f4-96cf-5dc4c5b5d72e","name":"=content_to_write","value":"={{ $json.content_to_write }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[592,-160],"id":"6df86b79-6df6-47a7-aeb5-c12c3c0a6d56","name":"file_content1"},{"parameters":{"method":"POST","url":"http://python_service:5000/execute-task","sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"task_name\": \"write_file\",\n  \"payload\": {\n    \"filepath\": \"./latex_document/{{ $json.filename_output }}\",\n    \"content\": {{ JSON.stringify($json.content_to_write) }}\n  }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[816,-160],"id":"e8b7ae13-ff05-4294-acc1-59114c62b01d","name":"write_file_request1"},{"parameters":{"jsCode":"// ⚡ Đây là hàm \"thần kỳ\" giúp chuyển đổi text thường sang LaTeX không đảo các phương án ID EX và TF\n// Nó sẽ tìm các công thức (H_2, Fe^{3+}) và các con số (2, 3) để bọc chúng bằng $...$\nconst latexify = (text) => {\n  // 1. Wrap các biểu thức toán học (ví dụ: 2 × 2 = 4)\n  // \\u00D7 là ký tự '×', \\u002A là '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. Xử lý phần text còn lại\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // 🔥FIX (PHƯƠNG ÁN B+): Đã cập nhật regex để bao gồm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // Đây là text thường (nằm ngoài dấu $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap các công thức hóa học (dùng regex mới)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap các con số độc lập\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text thường, wrap số\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // Công thức, giữ nguyên\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // Đây là text toán học (nằm trong dấu $...$), giữ nguyên\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // Dọn dẹp nếu có $$ trống\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n\n// === PHẦN XỬ LÝ CHÍNH TRONG N8N ===\n\n// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// Lặp qua từng item (ví dụ: nếu node trước trả về nhiều JSON)\nfor (const item of items) {\n  // 🔥 CẬP NHẬT: Xử lý JSON bị lồng (flat map)\n  // Dữ liệu JSON của bạn có cấu trúc lồng nhau, ta cần làm phẳng nó\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // Đảm bảo rawQuestionData là mảng trước khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n  \n  // Mảng này sẽ chứa các chuỗi LaTeX cho TỪNG câu hỏi\n  const questionLatexStrings = [];\n\n  // 🏗️ Dùng vòng lặp for...of để duyệt qua từng câu hỏi\n  for (const question of questions) {\n    \n    // Thêm header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // 🔥 CẬP NHẬT: Dùng \\begin{bt} nếu là BT, ngược lại dùng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Thêm tiêu đề (đã được \"latexify\")\n    // Thêm \\n để xuống dòng cho đẹp\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // 🔥 --- START CẬP NHẬT LOGIC 4 NHÁNH (EX, TF, SA, BT) ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT'); // Mới\n    \n    // 1. Thêm khối lựa chọn \\choice, \\choiceTF, \\shortans, hoặc không gì cả\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      // Lấy đáp án ngắn từ \"choices\"\n      const answer = question.choices[0].content;\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // Mặc định là EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua các lựa chọn (CHỈ DÀNH CHO EX và TF)\n    if (!isShortAnswer && !isTableExercise) { // Thêm !isTableExercise\n      for (const choice of question.choices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Thêm khối lời giải\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- Lời giải cho TF ---\n      const keyParts = [];\n      question.choices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of question.explanation) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- Lời giải cho SA ---\n      // Ghép các dòng giải thích thành 1 đoạn văn\n      const explanationText = question.explanation.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- Lời giải cho EX và BT (dùng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      for (const line of question.explanation) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // 🔥 CẬP NHẬT: Dùng \\end{bt} nếu là BT, ngược lại dùng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n    // 🔥 --- END CẬP NHẬT ---\n  }\n  \n  // Nối tất cả các câu hỏi của item này lại, cách nhau 2 dòng mới\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// 🚀 Trả về kết quả\nreturn [{\n  json: {\n    // Nối kết quả từ tất cả item đầu vào\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-512,-528],"id":"1f9d113a-1610-4f1f-9cff-1c8cc646008d","name":"Convert_code_latex_non_dao_pa"},{"parameters":{"jsCode":"// ⚡ Đây là hàm \"thần kỳ\" giúp chuyển đổi text thường sang LaTeX\n// Nó sẽ tìm các công thức (H_2, Fe^{3+}) và các con số (2, 3) để bọc chúng bằng $...$\nconst latexify = (text) => {\n  // 1. Wrap các biểu thức toán học (ví dụ: 2 × 2 = 4)\n  // \\u00D7 là ký tự '×', \\u002A là '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. Xử lý phần text còn lại\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // 🔥FIX (PHƯƠNG ÁN B+): Đã cập nhật regex để bao gồm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // Đây là text thường (nằm ngoài dấu $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap các công thức hóa học (dùng regex mới)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap các con số độc lập\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text thường, wrap số\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // Công thức, giữ nguyên\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // Đây là text toán học (nằm trong dấu $...$), giữ nguyên\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // Dọn dẹp nếu có $$ trống\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// 🔥 --- START CẬP NHẬT: Thêm hàm Shuffle ---\n/**\n * Xáo trộn một mảng (Fisher-Yates Shuffle).\n * @param {Array} array Mảng cần xáo trộn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// 🔥 --- END CẬP NHẬT ---\n\n\n// === PHẦN XỬ LÝ CHÍNH TRONG N8N ===\n\n// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// Lặp qua từng item (ví dụ: nếu node trước trả về nhiều JSON)\nfor (const item of items) {\n  // 🔥 CẬP NHẬT: Xử lý JSON bị lồng (flat map)\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // Đảm bảo rawQuestionData là mảng trước khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n  \n  // Mảng này sẽ chứa các chuỗi LaTeX cho TỪNG câu hỏi\n  const questionLatexStrings = [];\n\n  // 🏗️ Dùng vòng lặp for...of để duyệt qua từng câu hỏi\n  for (const question of questions) {\n    \n    // Thêm header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // 🔥 CẬP NHẬT: Dùng \\begin{bt} nếu là BT, ngược lại dùng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Thêm tiêu đề (đã được \"latexify\")\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // --- Xác định loại câu hỏi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // 🔥 --- START CẬP NHẬT: Logic Shuffle ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    // Chỉ shuffle cho EX và TF, và phải đảm bảo 2 mảng đồng bộ\n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      // 1. \"Zip\" 2 mảng lại\n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      // 2. Shuffle mảng \"zipped\"\n      shuffleArray(combined);\n      \n      // 3. \"Unzip\" mảng đã shuffle\n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    // 🔥 --- END CẬP NHẬT: Logic Shuffle ---\n    \n    // 1. Thêm khối lựa chọn \\choice, \\choiceTF, \\shortans, hoặc không gì cả\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content; // Dùng processedChoices\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // Mặc định là EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua các lựa chọn (CHỈ DÀNH CHO EX và TF)\n    if (!isShortAnswer && !isTableExercise) {\n      // 🔥 CẬP NHẬT: Dùng processedChoices\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Thêm khối lời giải\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- Lời giải cho TF ---\n      const keyParts = [];\n      // 🔥 CẬP NHẬT: Dùng processedChoices để tạo key mới\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(','); // Key mới: [T1,T2,F3,F4]\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      // 🔥 CẬP NHẬT: Dùng processedExplanations\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- Lời giải cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- Lời giải cho EX và BT (dùng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      // 🔥 CẬP NHẬT: Dùng processedExplanations\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // 🔥 CẬP NHẬT: Dùng \\end{bt} nếu là BT, ngược lại dùng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n  }\n  \n  // Nối tất cả các câu hỏi của item này lại, cách nhau 2 dòng mới\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// 🚀 Trả về kết quả\nreturn [{\n  json: {\n    // Nối kết quả từ tất cả item đầu vào\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-240,-528],"id":"8b328d4a-603e-453f-b906-35ac86c8af11","name":"Convert_to_latex_dao_PA1"},{"parameters":{"jsCode":"// ⚡ Đây là hàm \"thần kỳ\" giúp chuyển đổi text thường sang LaTeX\n// Nó sẽ tìm các công thức (H_2, Fe^{3+}) và các con số (2, 3) để bọc chúng bằng $...$\nconst latexify = (text) => {\n  // 1. Wrap các biểu thức toán học (ví dụ: 2 × 2 = 4)\n  // \\u00D7 là ký tự '×', \\u002A là '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. Xử lý phần text còn lại\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // 🔥FIX (PHƯƠNG ÁN B+): Đã cập nhật regex để bao gồm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // Đây là text thường (nằm ngoài dấu $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap các công thức hóa học (dùng regex mới)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap các con số độc lập\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text thường, wrap số\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // Công thức, giữ nguyên\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // Đây là text toán học (nằm trong dấu $...$), giữ nguyên\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // Dọn dẹp nếu có $$ trống\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// 🔥 --- START CẬP NHẬT: Thêm hàm Shuffle ---\n/**\n * Xáo trộn một mảng (Fisher-Yates Shuffle).\n * @param {Array} array Mảng cần xáo trộn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// 🔥 --- END CẬP NHẬT ---\n\n\n// === PHẦN XỬ LÝ CHÍNH TRONG N8N ===\n\n// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\nlet allLatexOutputs = [];\n\n// Lặp qua từng item (ví dụ: nếu node trước trả về nhiều JSON)\nfor (const item of items) {\n  // 🔥 CẬP NHẬT: Xử lý JSON bị lồng (flat map)\n  const rawQuestionData = item.json.cau_hoi_latex;\n  // Đảm bảo rawQuestionData là mảng trước khi flatMap\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // 🔥 --- START CẬP NHẬT MỚI: Xáo trộn vị trí các câu hỏi ---\n  // Dòng này sẽ xáo trộn thứ tự của [EX_1, EX_2, TF_1, SA_1, BT_1, ...]\n  shuffleArray(questions);\n  // 🔥 --- END CẬP NHẬT MỚI ---\n\n  // Mảng này sẽ chứa các chuỗi LaTeX cho TỪNG câu hỏi\n  const questionLatexStrings = [];\n\n  // 🏗️ Dùng vòng lặp for...of để duyệt qua từng câu hỏi (theo thứ tự đã xáo trộn)\n  for (const question of questions) {\n    \n    // Thêm header\n    questionLatexStrings.push(`%%%============${question.id}=============%%%`);\n    // 🔥 CẬP NHẬT: Dùng \\begin{bt} nếu là BT, ngược lại dùng \\begin{ex}\n    if (question.id.includes('BT')) {\n      questionLatexStrings.push(`\\\\begin{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\begin{ex}`);\n    }\n    \n    // Thêm tiêu đề (đã được \"latexify\")\n    questionLatexStrings.push(`  ${latexify(question.title)}`);\n    \n    // --- Xác định loại câu hỏi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // 🔥 --- START CẬP NHẬT: Logic Shuffle (bên trong câu hỏi) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    // Chỉ shuffle cho EX và TF, và phải đảm bảo 2 mảng đồng bộ\n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      // 1. \"Zip\" 2 mảng lại\n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      // 2. Shuffle mảng \"zipped\" (Shuffle bên trong)\n      shuffleArray(combined);\n      \n      // 3. \"Unzip\" mảng đã shuffle\n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    // 🔥 --- END CẬP NHẬT: Logic Shuffle (bên trong câu hỏi) ---\n    \n    // 1. Thêm khối lựa chọn \\choice, \\choiceTF, \\shortans, hoặc không gì cả\n    if (isTrueFalse) {\n      questionLatexStrings.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content; // Dùng processedChoices\n      questionLatexStrings.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT_ type has no choice/shortans block, do nothing.\n    } else { // Mặc định là EX\n      questionLatexStrings.push(`  \\\\choice`);\n    }\n    \n    // 2. Loop qua các lựa chọn (CHỈ DÀNH CHO EX và TF)\n    if (!isShortAnswer && !isTableExercise) {\n      // 🔥 CẬP NHẬT: Dùng processedChoices (đã xáo trộn)\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        questionLatexStrings.push(`  {${choicePrefix}${choiceContent}}`);\n      }\n    }\n    \n    // 3. Thêm khối lời giải\n    questionLatexStrings.push(`  \\\\loigiai{`);\n\n    if (isTrueFalse) {\n      // --- Lời giải cho TF ---\n      const keyParts = [];\n      // 🔥 CẬP NHẬT: Dùng processedChoices (đã xáo trộn) để tạo key mới\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(','); // Key mới: [T1,T2,F3,F4]\n      \n      questionLatexStrings.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      // 🔥 CẬP NHẬT: Dùng processedExplanations (đã xáo trộn)\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- Lời giải cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      questionLatexStrings.push(`    ${explanationText}`);\n\n    } else {\n      // --- Lời giải cho EX và BT (dùng itemize) ---\n      questionLatexStrings.push(`    \\\\begin{itemize}`);\n      // 🔥 CẬP NHẬT: Dùng processedExplanations (đã xáo trộn nếu là EX)\n      for (const line of processedExplanations) {\n        questionLatexStrings.push(`      \\\\item ${latexify(line)}`);\n      }\n      questionLatexStrings.push(`    \\\\end{itemize}`);\n    }\n    \n    questionLatexStrings.push(`  }`);\n    \n    // 🔥 CẬP NHẬT: Dùng \\end{bt} nếu là BT, ngược lại dùng \\end{ex}\n    if (isTableExercise) {\n      questionLatexStrings.push(`\\\\end{bt}`);\n    } else {\n      questionLatexStrings.push(`\\\\end{ex}`);\n    }\n  }\n  \n  // Nối tất cả các câu hỏi của item này lại, cách nhau 2 dòng mới\n  allLatexOutputs.push(questionLatexStrings.join('\\n'));\n}\n\n// 🚀 Trả về kết quả\nreturn [{\n  json: {\n    // Nối kết quả từ tất cả item đầu vào\n    latex_output: allLatexOutputs.join('\\n\\n')\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[368,-528],"id":"3951e7e7-0274-4999-89ba-595fe662559a","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi"},{"parameters":{"jsCode":"// ⚡ Đây là hàm \"thần kỳ\" giúp chuyển đổi text thường sang LaTeX\n// Nó sẽ tìm các công thức (H_2, Fe^{3+}) và các con số (2, 3) để bọc chúng bằng $...$\nconst latexify = (text) => {\n  // 1. Wrap các biểu thức toán học (ví dụ: 2 × 2 = 4)\n  // \\u00D7 là ký tự '×', \\u002A là '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. Xử lý phần text còn lại\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // 🔥FIX (PHƯƠNG ÁN B+): Đã cập nhật regex để bao gồm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // Đây là text thường (nằm ngoài dấu $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap các công thức hóa học (dùng regex mới)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap các con số độc lập\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text thường, wrap số\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // Công thức, giữ nguyên\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // Đây là text toán học (nằm trong dấu $...$), giữ nguyên\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // Dọn dẹp nếu có $$ trống\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// 🔥 --- START: Thêm hàm Shuffle ---\n/**\n * Xáo trộn một mảng (Fisher-Yates Shuffle).\n * @param {Array} array Mảng cần xáo trộn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// 🔥 --- END: Thêm hàm Shuffle ---\n\n// 🔥 --- START: Hàm xử lý mảng câu hỏi ---\n/**\n * Xử lý một mảng các câu hỏi và trả về một mảng các chuỗi LaTeX.\n * @param {Array} questionArray - Mảng các đối tượng câu hỏi (ví dụ: exQuestions).\n * @returns {Array<string>} - Mảng các chuỗi LaTeX đã xử lý.\n */\nconst processQuestionsToLatex = (questionArray) => {\n  // Biến này chứa TẤT CẢ các chuỗi LaTeX của các câu hỏi trong nhóm này\n  const allQuestionStrings = []; \n  \n  // 🏗️ Dùng vòng lặp for...of để duyệt qua từng câu hỏi (theo thứ tự đã xáo trộn)\n  for (const question of questionArray) {\n    // 🔥 FIX LÀ Ở ĐÂY:\n    // Biến này CHỈ chứa các dòng cho MỘT câu hỏi\n    const singleQuestionLines = []; \n\n    // Thêm header\n    singleQuestionLines.push(`%%%============${question.id}=============%%%`);\n    if (question.id.includes('BT')) {\n      singleQuestionLines.push(`\\\\begin{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\begin{ex}`);\n    }\n    \n    // Thêm tiêu đề\n    singleQuestionLines.push(`  ${latexify(question.title)}`);\n    \n    // --- Xác định loại câu hỏi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // --- Logic Shuffle (bên trong câu hỏi EX/TF) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      shuffleArray(combined); // Shuffle bên trong\n      \n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    \n    // 1. Thêm khối lựa chọn\n    if (isTrueFalse) {\n      singleQuestionLines.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content;\n      singleQuestionLines.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT không có khối lựa chọn\n    } else { // Mặc định là EX\n      singleQuestionLines.push(`  \\\\choice`); // Dùng singleQuestionLines\n    }\n    \n    // 2. Loop qua các lựa chọn (CHỈ DÀNH CHO EX và TF)\n    if (!isShortAnswer && !isTableExercise) {\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        singleQuestionLines.push(`  {${choicePrefix}${choiceContent}}`); // Dùng singleQuestionLines\n      }\n    }\n    \n    // 3. Thêm khối lời giải\n    singleQuestionLines.push(`  \\\\loigiai{`); // Dùng singleQuestionLines\n\n    if (isTrueFalse) {\n      // --- Lời giải cho TF ---\n      const keyParts = [];\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      singleQuestionLines.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- Lời giải cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      singleQuestionLines.push(`    ${explanationText}`);\n\n    } else {\n      // --- Lời giải cho EX và BT (dùng itemize) ---\n      singleQuestionLines.push(`    \\\\begin{itemize}`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemize}`);\n    }\n    \n    singleQuestionLines.push(`  }`); // Dùng singleQuestionLines\n    \n    // Đóng khối \\begin\n    if (isTableExercise) {\n      singleQuestionLines.push(`\\\\end{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\end{ex}`);\n    }\n    \n    // Nối các dòng của câu hỏi này thành 1 string và push vào mảng TỔNG\n    allQuestionStrings.push(singleQuestionLines.join('\\n'));\n  }\n  \n  return allQuestionStrings;\n};\n// 🔥 --- END: Hàm xử lý ---\n\n\n// === PHẦN XỬ LÝ CHÍNH TRONG N8N ===\n\n// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\nlet finalOutput = [];\n\n// Lặp qua từng item (ví dụ: nếu node trước trả về nhiều JSON)\nfor (const item of items) {\n  // 1. Lấy và làm phẳng data\n  const rawQuestionData = item.json.cau_hoi_latex;\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // 2. Tạo 4 mảng để phân loại\n  const exQuestions = [];\n  const tfQuestions = [];\n  const saQuestions = [];\n  const btQuestions = [];\n\n  // 3. Phân loại câu hỏi\n  for (const question of questions) {\n    if (question.id.includes('BT')) {\n      btQuestions.push(question);\n    } else if (question.id.includes('TF')) {\n      tfQuestions.push(question);\n    } else if (question.id.includes('SA')) {\n      saQuestions.push(question);\n    } else { // Mặc định là EX\n      exQuestions.push(question);\n    }\n  }\n\n  // 4. Xáo trộn các câu hỏi *trong* từng nhóm\n  shuffleArray(exQuestions);\n  shuffleArray(tfQuestions);\n  shuffleArray(saQuestions);\n  shuffleArray(btQuestions);\n\n  // 5. Xử lý từng nhóm đã xáo trộn để tạo mảng string LaTeX\n  const exOutput = processQuestionsToLatex(exQuestions);\n  const tfOutput = processQuestionsToLatex(tfQuestions);\n  const saOutput = processQuestionsToLatex(saQuestions);\n  const btOutput = processQuestionsToLatex(btQuestions);\n\n  // 6. Push kết quả của item này vào\n  finalOutput.push({\n    json: {\n      EX: exOutput,\n      TF: tfOutput,\n      SA: saOutput,\n      BT: btOutput\n    }\n  });\n}\n\n// 🚀 Trả về kết quả\n// Trả về một mảng các object, mỗi object tương ứng với một item đầu vào\n// và chứa 4 mảng đã được phân loại\nreturn finalOutput;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[48,-528],"id":"fcc4b2fd-35ae-46cc-99c5-5b28b13759cf","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID"},{"parameters":{"jsCode":"// ⚡ Đây là hàm \"thần kỳ\" giúp chuyển đổi text thường sang LaTeX\n// Nó sẽ tìm các công thức (H_2, Fe^{3+}) và các con số (2, 3) để bọc chúng bằng $...$\nconst latexify = (text) => {\n  // 1. Wrap các biểu thức toán học (ví dụ: 2 × 2 = 4)\n  // \\u00D7 là ký tự '×', \\u002A là '*'\n  let result = text.replace(/(\\d+\\s*[\\u00D7\\u002A]\\s*\\d+\\s*=\\s*\\d+)/g, '$$$1$$');\n\n  // 2. Xử lý phần text còn lại\n  const segments = result.split('$');\n  let finalResult = '';\n\n  // 🔥FIX (PHƯƠNG ÁN B+): Đã cập nhật regex để bao gồm ^ { } + -\n  const formulaRegex = /(?<=^|\\s|\\(|\\[)(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?(?=$|\\s|\\.|\\,|\\:|\\?|\\!|\\)|\\])/g;\n\n\n  for (let i = 0; i < segments.length; i++) {\n    if (i % 2 === 0) {\n      // Đây là text thường (nằm ngoài dấu $...$)\n      let temp = segments[i];\n      \n      // 2a. Wrap các công thức hóa học (dùng regex mới)\n      temp = temp.replace(formulaRegex, '$$$1$$');\n      \n      // 2b. Wrap các con số độc lập\n      const formulaSegments = temp.split('$');\n      let tempResult = '';\n      for (let j = 0; j < formulaSegments.length; j++) {\n        if (j % 2 === 0) {\n          // Text thường, wrap số\n          tempResult += formulaSegments[j].replace(/\\b(\\d+)\\b/g, '$$$1$$');\n        } else {\n          // Công thức, giữ nguyên\n          tempResult += `$${formulaSegments[j]}$`;\n        }\n      }\n      finalResult += tempResult;\n      \n    } else {\n      // Đây là text toán học (nằm trong dấu $...$), giữ nguyên\n      finalResult += `$${segments[i]}$`;\n    }\n  }\n  // Dọn dẹp nếu có $$ trống\n  return finalResult.replace(/\\$\\s*\\$/g, ' ');\n};\n\n// 🔥 --- START: Thêm hàm Shuffle (Dùng để xáo trộn lựa chọn bên trong) ---\n/**\n * Xáo trộn một mảng (Fisher-Yates Shuffle).\n * @param {Array} array Mảng cần xáo trộn.\n */\nconst shuffleArray = (array) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n};\n// 🔥 --- END: Thêm hàm Shuffle ---\n\n// 🔥 --- START CẬP NHẬT MỚI: Thêm hàm lấy số ID ---\n/**\n * Lấy phần số từ ID (ví dụ: \"EX_10\" -> 10) để sắp xếp\n * @param {string} id\n * @returns {number}\n */\nconst getIdNumber = (id) => {\n  if (typeof id !== 'string') return 0;\n  const parts = id.split('_');\n  // Lấy phần tử cuối cùng (phòng trường hợp ID như \"SOME_TF_1\")\n  return parseInt(parts[parts.length - 1] || 0, 10);\n};\n// 🔥 --- END CẬP NHẬT MỚI ---\n\n\n// 🔥 --- START: Hàm xử lý mảng câu hỏi ---\n/**\n * Xử lý một mảng các câu hỏi và trả về một mảng các chuỗi LaTeX.\n * @param {Array} questionArray - Mảng các đối tượng câu hỏi (ví dụ: exQuestions).\n * @returns {Array<string>} - Mảng các chuỗi LaTeX đã xử lý.\n */\nconst processQuestionsToLatex = (questionArray) => {\n  // Biến này chứa TẤT CẢ các chuỗi LaTeX của các câu hỏi trong nhóm này\n  const allQuestionStrings = []; \n  \n  // 🏗️ Dùng vòng lặp for...of để duyệt qua từng câu hỏi (theo thứ tự đã SẮP XẾP)\n  for (const question of questionArray) {\n    // Biến này CHỈ chứa các dòng cho MỘT câu hỏi\n    const singleQuestionLines = []; \n\n    // Thêm header\n    singleQuestionLines.push(`%%%============${question.id}=============%%%`);\n    if (question.id.includes('BT')) {\n      singleQuestionLines.push(`\\\\begin{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\begin{ex}`);\n    }\n    \n    // Thêm tiêu đề\n    singleQuestionLines.push(`  ${latexify(question.title)}`);\n    \n    // --- Xác định loại câu hỏi ---\n    const isTrueFalse = question.id.includes('TF');\n    const isShortAnswer = question.id.includes('SA');\n    const isTableExercise = question.id.includes('BT');\n    \n    // --- Logic Shuffle (bên trong câu hỏi EX/TF) ---\n    let processedChoices = question.choices;\n    let processedExplanations = question.explanation;\n    \n    const isShuffleType = (question.id.includes('EX') || isTrueFalse);\n\n    if (isShuffleType && \n        Array.isArray(question.choices) && \n        Array.isArray(question.explanation) && \n        question.choices.length === question.explanation.length) {\n      \n      let combined = question.choices.map((choice, index) => {\n        return {\n          choice: choice,\n          explanation: question.explanation[index]\n        };\n      });\n      \n      shuffleArray(combined); // Shuffle bên trong\n      \n      processedChoices = combined.map(pair => pair.choice);\n      processedExplanations = combined.map(pair => pair.explanation);\n    }\n    \n    // 1. Thêm khối lựa chọn\n    if (isTrueFalse) {\n      singleQuestionLines.push(`  \\\\choiceTF`);\n    } else if (isShortAnswer) {\n      const answer = processedChoices[0].content;\n      singleQuestionLines.push(`  \\\\shortans{${latexify(answer)}}`);\n    } else if (isTableExercise) {\n      // BT không có khối lựa chọn\n    } else { // Mặc định là EX\n      singleQuestionLines.push(`  \\\\choice`); \n    }\n    \n    // 2. Loop qua các lựa chọn (CHỈ DÀNH CHO EX và TF)\n    if (!isShortAnswer && !isTableExercise) {\n      for (const choice of processedChoices) {\n        const choicePrefix = choice.correct ? '\\\\True ' : '';\n        let choiceContent = '';\n        const testRegex = /^(?:'|\")?([A-Z][A-Za-z]*[0-9_^][A-Za-z0-9_^\\{\\}+-]*|[0-9]+[A-Z][A-Za-z0-9_^\\{\\}+-]*)(?:'|\")?$/;\n        const match = choice.content.match(testRegex);\n        \n        if (match) {\n          choiceContent = `$${match[1]}$`; \n        } else {\n          choiceContent = latexify(choice.content);\n        }\n        \n        singleQuestionLines.push(`  {${choicePrefix}${choiceContent}}`); \n      }\n    }\n    \n    // 3. Thêm khối lời giải\n    singleQuestionLines.push(`  \\\\loigiai{`); \n\n    if (isTrueFalse) {\n      // --- Lời giải cho TF ---\n      const keyParts = [];\n      processedChoices.forEach((choice, index) => {\n        const letter = choice.correct ? 'T' : 'F';\n        const number = index + 1;\n        keyParts.push(`${letter}${number}`);\n      });\n      const itemChoiceKey = keyParts.join(',');\n      \n      singleQuestionLines.push(`    \\\\begin{itemchoice}[${itemChoiceKey}]`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemchoice}`);\n\n    } else if (isShortAnswer) {\n      // --- Lời giải cho SA ---\n      const explanationText = processedExplanations.map(line => latexify(line)).join(' ');\n      singleQuestionLines.push(`    ${explanationText}`);\n\n    } else {\n      // --- Lời giải cho EX và BT (dùng itemize) ---\n      singleQuestionLines.push(`    \\\\begin{itemize}`);\n      for (const line of processedExplanations) {\n        singleQuestionLines.push(`      \\\\item ${latexify(line)}`);\n      }\n      singleQuestionLines.push(`    \\\\end{itemize}`);\n    }\n    \n    singleQuestionLines.push(`  }`); \n    \n    // Đóng khối \\begin\n    if (isTableExercise) {\n      singleQuestionLines.push(`\\\\end{bt}`);\n    } else {\n      singleQuestionLines.push(`\\\\end{ex}`);\n    }\n    \n    // Nối các dòng của câu hỏi này thành 1 string và push vào mảng TỔNG\n    allQuestionStrings.push(singleQuestionLines.join('\\n'));\n  }\n  \n  return allQuestionStrings;\n};\n// 🔥 --- END: Hàm xử lý ---\n\n\n// === PHẦN XỬ LÝ CHÍNH TRONG N8N ===\n\n// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\nlet finalOutput = [];\n\n// Lặp qua từng item (ví dụ: nếu node trước trả về nhiều JSON)\nfor (const item of items) {\n  // 1. Lấy và làm phẳng data\n  const rawQuestionData = item.json.cau_hoi_latex;\n  const questions = Array.isArray(rawQuestionData) \n    ? rawQuestionData.flatMap(q => q.cau_hoi_latex ? q.cau_hoi_latex : q)\n    : [];\n\n  // 2. Tạo 4 mảng để phân loại\n  const exQuestions = [];\n  const tfQuestions = [];\n  const saQuestions = [];\n  const btQuestions = [];\n\n  // 3. Phân loại câu hỏi\n  for (const question of questions) {\n    if (question.id.includes('BT')) {\n      btQuestions.push(question);\n    } else if (question.id.includes('TF')) {\n      tfQuestions.push(question);\n    } else if (question.id.includes('SA')) {\n      saQuestions.push(question);\n    } else { // Mặc định là EX\n      exQuestions.push(question);\n    }\n  }\n\n  // 4. 🔥 CẬP NHẬT MỚI: Sắp xếp các câu hỏi *trong* từng nhóm theo ID\n  const sortById = (a, b) => getIdNumber(a.id) - getIdNumber(b.id);\n  exQuestions.sort(sortById);\n  tfQuestions.sort(sortById);\n  saQuestions.sort(sortById);\n  btQuestions.sort(sortById);\n\n  // 5. Xử lý từng nhóm đã SẮP XẾP để tạo mảng string LaTeX\n  const exOutput = processQuestionsToLatex(exQuestions);\n  const tfOutput = processQuestionsToLatex(tfQuestions);\n  const saOutput = processQuestionsToLatex(saQuestions);\n  const btOutput = processQuestionsToLatex(btQuestions);\n\n  // 6. Push kết quả của item này vào\n  finalOutput.push({\n    json: {\n      EX: exOutput,\n      TF: tfOutput,\n      SA: saOutput,\n      BT: btOutput\n    }\n  });\n}\n\n// 🚀 Trả về kết quả\n// Trả về một mảng các object, mỗi object tương ứng với một item đầu vào\n// và chứa 4 mảng đã được phân loại\nreturn finalOutput;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-512,144],"id":"9b8b0869-594f-486a-b44a-b325395cec02","name":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX"},{"parameters":{"jsCode":"// Lấy dữ liệu từ TẤT CẢ item, bất kể chế độ Execute Once\nconst items = $input.all();\n\n// 💡 Dữ liệu của bạn là một mảng [ { ... } ], chúng ta cần lấy object đầu tiên\nconst inputData = items[0].json;\n\n// 1. Khởi tạo object kết quả\nconst outputObject = {\n  \"EX\": \"\",\n  \"TF\": \"\",\n  \"SA\": \"\",\n  \"BT\": \"\"\n};\n\n// 2. Định nghĩa các key chúng ta muốn xử lý\nconst keysToProcess = ['EX', 'TF', 'SA', 'BT'];\n\n// 🏗️ Dùng vòng lặp 'for...of' (một dạng 'for' hiện đại) để duyệt qua các key\nfor (const key of keysToProcess) {\n  \n  // Lấy mảng tương ứng (ví dụ: inputData['EX'])\n  const stringArray = inputData[key];\n  \n  // Tạo một chuỗi rỗng để \"cộng dồn\"\n  let concatenatedString = \"\";\n\n  // 🏗️ Dùng vòng lặp 'for' cổ điển (như bạn yêu cầu) để duyệt qua từng phần tử\n  for (let i = 0; i < stringArray.length; i++) {\n    \n    // Nối (cộng) chuỗi hiện tại vào chuỗi tổng\n    concatenatedString += stringArray[i];\n    \n    // Thêm 2 dấu xuống dòng để ngăn cách các câu hỏi cho dễ đọc\n    // (Bỏ qua nếu là phần tử cuối cùng)\n    if (i < stringArray.length - 1) {\n      concatenatedString += \"\\n\\n\";\n    }\n  }\n  \n  // 3. Gán chuỗi đã nối vào object kết quả\n  outputObject[key] = concatenatedString;\n}\n\n// 4. 🚀 Trả về kết quả\n// Chúng ta trả về một item duy nhất chứa object bạn mong muốn\nreturn [{\n  json: outputObject\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-288,144],"id":"58389f5e-3cd2-4b5d-90f7-ef7af74d29a8","name":"JOIN"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"JSON_LATEX","type":"main","index":0}]]},"JSON_LATEX":{"main":[[{"node":"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX","type":"main","index":0}]]},"CODE_LATEX":{"main":[[]]},"Tempt":{"main":[[{"node":"file_content1","type":"main","index":0}]]},"input_file1":{"main":[[{"node":"Read/Write Files from Disk","type":"main","index":0}]]},"file_content1":{"main":[[{"node":"write_file_request1","type":"main","index":0}]]},"write_file_request1":{"main":[[{"node":"input_file1","type":"main","index":0}]]},"Convert_code_latex_non_dao_pa":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID":{"main":[[]]},"Convert_to_latex_dao_PA_and_dao_cau_hoi_theo_ID_INDEX":{"main":[[{"node":"JOIN","type":"main","index":0}]]},"JOIN":{"main":[[{"node":"CODE_LATEX","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":null,"pinData":{},"versionId":"70ac822a-5bae-4880-bb13-5d71365704c2","triggerCount":0,"shared":[{"createdAt":"2025-10-26T05:25:43.765Z","updatedAt":"2025-10-26T05:25:43.765Z","role":"workflow:owner","workflowId":"MS9CsgNhzyfs4Eh2","projectId":"EIQckweL3OLW7kzz"}],"tags":[]}